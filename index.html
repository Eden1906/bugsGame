<!doctype html>
<html lang="he" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>משחק יריות כפכפים</title>
  <style>
    body { margin: 0; background: #0f1226; overflow: hidden; }
    canvas { display: block; margin: 0 auto; background: #0b0f24; touch-action: none; }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  const W = () => canvas.width;
  const H = () => canvas.height;

  // טעינת תמונות
  const enemyImg = new Image(); enemyImg.src = "bugs.png";
  const playerImg = new Image(); playerImg.src = "player.png";
  const bulletImg = new Image(); bulletImg.src = "flipflop.png";

  let state = {
    running: true,
    gameOver: false,
    score: 0,
    lives: 3,
    fallSpeed: 2.2,
    spawnEverySec: 0.9,
    spawnTimer: 0,
    player: { x: W()/2, y: H()-90, w: 90, h: 90, speed: 8 },
    bullets: [],
    enemies: [],
    keys: { left: false, right: false },
    shootTimer: 0,
    dragging: false
  };

  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
  function rand(a,b){ return Math.random()*(b-a)+a; }
  function now(){ return performance.now()/1000; }

  // שליטה במחשב
  window.addEventListener('keydown', e => {
    if (e.code === 'ArrowLeft' || e.code === 'KeyA') state.keys.left = true;
    if (e.code === 'ArrowRight' || e.code === 'KeyD') state.keys.right = true;
    if (e.code === 'Enter' && state.gameOver) restart();
  });
  window.addEventListener('keyup', e => {
    if (e.code === 'ArrowLeft' || e.code === 'KeyA') state.keys.left = false;
    if (e.code === 'ArrowRight' || e.code === 'KeyD') state.keys.right = false;
  });

  // שליטה במגע ישירות על הדמות
  canvas.addEventListener('touchstart', e => {
    const touch = e.touches[0];
    const p = state.player;
    // בדיקה אם האצבע נוגעת בשחקן
    if (touch.clientX >= p.x - p.w/2 && touch.clientX <= p.x + p.w/2 &&
        touch.clientY >= p.y - p.h/2 && touch.clientY <= p.y + p.h/2) {
      state.dragging = true;
    }
  });
  canvas.addEventListener('touchmove', e => {
    if (!state.dragging) return;
    const touch = e.touches[0];
    state.player.x = clamp(touch.clientX, state.player.w/2+6, W()-state.player.w/2-6);
  });
  canvas.addEventListener('touchend', () => {
    state.dragging = false;
  });

  function restart(){
    state.running = true;
    state.gameOver = false;
    state.score = 0;
    state.bullets = [];
    state.enemies = [];
    state.player.x = W()/2;
    state.player.y = H()-90;
    state.spawnTimer = 0;
    state.lives = 3;
    state.shootTimer = 0;
  }

  function spawnEnemy(){
    const size = rand(80,120);
    const enemy = {
      x: rand(size/2, W()-size/2),
      y: -size/2,
      w: size,
      h: size,
      vy: state.fallSpeed * rand(0.9, 1.3),
      rotation: rand(-0.2, 0.2),
    };
    state.enemies.push(enemy);
  }

  function shoot(){
    const {x,y} = state.player;
    state.bullets.push({ x: x, y: y - 40, w: 80, h: 80, vy: -10 });
  }

  function update(dt){
    if (!state.running) return;

    if (state.keys.left) state.player.x -= state.player.speed;
    if (state.keys.right) state.player.x += state.player.speed;
    state.player.x = clamp(state.player.x, state.player.w/2+6, W()-state.player.w/2-6);

    // ירי אוטומטי
    state.shootTimer += dt;
    if (state.shootTimer >= 0.3){
      shoot();
      state.shootTimer = 0;
    }

    state.bullets.forEach(b => b.y += b.vy);
    state.bullets = state.bullets.filter(b => b.y > -50);

    state.spawnTimer += dt;
    if (state.spawnTimer >= state.spawnEverySec){
      state.spawnTimer = 0;
      spawnEnemy();
    }

    for (const e of state.enemies) e.y += e.vy;

    outer: for (let i=state.enemies.length-1; i>=0; i--){
      const e = state.enemies[i];
      for (let j=state.bullets.length-1; j>=0; j--){
        const b = state.bullets[j];
        if (circleRectCollide(b.x,b.y,30,e.x-e.w/2,e.y-e.h/2,e.w,e.h)){
          state.enemies.splice(i,1);
          state.bullets.splice(j,1);
          state.score += 10;
          continue outer;
        }
      }
    }

    for (let i=state.enemies.length-1; i>=0; i--){
      const e = state.enemies[i];
      if (e.y - e.h/2 > H()){
        state.enemies.splice(i,1);
        state.lives -= 1;
        if (state.lives <= 0){ gameOver(); break; }
      }
    }
  }

  function circleRectCollide(cx,cy,cr,rx,ry,rw,rh){
    const testX = clamp(cx,rx,rx+rw);
    const testY = clamp(cy,ry,ry+rh);
    const dx = cx - testX;
    const dy = cy - testY;
    return (dx*dx + dy*dy) <= cr*cr;
  }

  function gameOver(){ state.running = false; state.gameOver = true; }

  function draw(){
    ctx.clearRect(0,0,W(),H());

    drawPlayer();

    for (const b of state.bullets){
      if (bulletImg.complete){
        ctx.drawImage(bulletImg, b.x-b.w/2, b.y-b.h/2, b.w, b.h);
      }
    }

    for (const e of state.enemies){
      ctx.save();
      ctx.translate(e.x,e.y);
      ctx.rotate(e.rotation);
      if (enemyImg.complete){
        ctx.drawImage(enemyImg, -e.w/2,-e.h/2,e.w,e.h);
      }
      ctx.restore();
    }

    ctx.fillStyle = '#fff';
    ctx.font = '16px Arial';
    ctx.fillText(`ניקוד: ${state.score}`, 20, 30);
    ctx.fillText(`חיים: ${state.lives}`, 20, 50);

    if (state.gameOver){
      ctx.fillStyle = '#fff';
      ctx.font = '28px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Game Over', W()/2, H()/2);
      ctx.font = '16px Arial';
      ctx.fillText('לחץ Enter כדי להתחיל מחדש', W()/2, H()/2 + 30);
      ctx.textAlign = 'start';
    }
  }

  function drawPlayer(){
    const p = state.player;
    ctx.save();
    ctx.translate(p.x,p.y);
    if (playerImg.complete){
      ctx.drawImage(playerImg, -p.w/2, -p.h/2, p.w, p.h);
    }
    ctx.restore();
  }

  let last = now();
  function loop(){
    const t = now();
    const dt = Math.min(0.05, t-last);
    last = t;
    if (state.running) update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  restart();
  loop();
})();
</script>
</body>
</html>
